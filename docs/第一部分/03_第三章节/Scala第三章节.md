# Scala第三章节

### 章节目标

1. 理解运算符的相关概述
2. 掌握算术, 赋值, 关系, 逻辑运算符的用法
3. 掌握交换变量案例
4. 理解位运算符的用法

------

### 1. 算术运算符 

#### 1.1 运算符简介

用来拼接变量或者常量的符号就叫: 运算符, 而通过运算符连接起来的式子就叫: 表达式. 实际开发中, 我们会经常用到它.

例如:

​	10 + 3 这个就是一个表达式,  而+号, 就是一个运算符.

​	`注意: 在Scala中, 运算符并不仅仅是运算符, 也是函数的一种, 这点大家先了解即可, 后续我们详细讲解.`

#### 1.2 运算符的分类

 * 算术运算符

 * 赋值运算符

 * 关系运算符

 * 逻辑运算符

 * 位运算符

   > 注意: Scala中是没有三元运算符的, 被if-else给替代了.

#### 1.3 算术运算符

算术运算符指的就是`用来进行算术操作的符号`,  常用的有以下几种: 

| 运算符 | 功能解释                                                     |
| :----- | ------------------------------------------------------------ |
| +      | 加号, 功能有3点.   1) 表示正数    2) 普通的加法操作    3) 字符串的拼接 |
| -      | 减号, 功能有2点.    1) 表示负数   2) 普通的减法操作          |
| *      | 乘号,  用于获取两个数据的乘积                                |
| /      | 除法,  用于获取两个数据的商                                  |
| %      | 取余(也叫取模),  用于获取两个数据的余数                      |

> 注意:
>
> 1. Scala中是没有++, --这两个算术运算符的,  这点和Java中不同.
>
> 2. 整数相除的结果, 还是整数. 如果想获取到小数, 则必须有浮点型数据参与.
>
>    ` 例如: 10 / 3  结果是3      10 / 3.0  结果是: 3.3333(无限循环)`
>
> 3. 关于+号拼接字符串:  任意类型的数据和字符串拼接, 结果都将是一个新的字符串.
>
> 4. 关于%操作, 假设求`a % b`的值, 它的底层原理其实是:  `a - a/b * b`

#### 1.4 代码演示

需求: 演示算术运算符的常见操作.

参考代码:

```scala
//演示+号操作
println(+3)
println(10 + 3)
println("hello" + 10)

//演示-号操作
println(-5)
println(10 - 5)

//演示*号操作
println(5 * 3)

//演示/号操作
println(10 / 3)
println(10 / 3.0)

//演示%(取余)操作
println(10 % 3)     //结果是1, 具体运算过程: 10 - 10/3 * 3   = 10 - 3 * 3   = 1
println(10 % -3)    //结果是1, 具体运算过程: 10 - 10/-3 * -3 = 10 - -3 * -3 = 10 - 9  =  1
println(-10 % 3)   //结果是-1, 具体运算过程: -10 - -10/3 * 3 = -10 - -3 * 3 = -10 + 9 = -1 
```



### 2. 赋值运算符

#### 2.1 概述

赋值运算符指的就是`用来进行赋值操作的符号`.   例如: 把一个常量值, 或者一个变量值甚至是某一段代码的执行结果赋值给变量, 这些都要用到赋值运算符.

#### 2.2 分类

* 赋值运算符常用的有两类

  * 基本赋值运算符

    `=`就是基本的赋值运算符,   例如:  var a:Int = 3,  就是把常量值3赋值给变量a

  * 扩展赋值运算符

    `+=, -=, *=, /=, %=`

  > 注意:
  >
  > 1. 赋值运算符的左边必须是: 变量,  不能是常量.    例如:  3 = 5,   这种写法就是错误的. 
  >
  > 2. 关于扩展赋值运算符, 其实就是把左边的数据和右边的数据进行指定的操作, 然后把结果赋值给左边.
  >
  >    `例如; a += 3 就是把变量a的值和常量3进行加法操作, 然后把结果赋值给变量a`

#### 2.3 代码演示

```Scala
//将常量值1赋值给变量a
var a:Int = 1			//注意: 因为后续代码要修改变量a的值, 所以变量a要用var修饰
//对变量a进行加3操作, 然后把结果重新赋值给变量a
a += 3			//a的最终结果为: a = 4
//对变量a进行减2操作, 然后把结果重新赋值给变量a
a -= 2			//a的最终结果为: a = 2
//对变量a进行乘3操作, 然后把结果重新赋值给变量a
a *= 3			//a的最终结果为: a = 6
//对变量a进行除2操作, 然后把结果重新赋值给变量a
a /= 2			//a的最终结果为: a = 3
//对变量a和2进行取余操作, 然后把结果重新赋值给变量a
a %= 2			//a的最终结果为: a = 1
```



### 3. 关系运算符

#### 3.1 概述

关系运算符指的就是`用来进行比较操作的符号`.  例如: 数据是否相等, 是否不等, 数据1大还是数据2大...等这些操作.

#### 3.2 分类

| 运算符 | 功能解释                                       |
| ------ | ---------------------------------------------- |
| >      | 用来判断前边的数据`是否大于`后边的数据         |
| >=     | 用来判断前边的数据`是否大于或者等于`后边的数据 |
| <      | 用来判断前边的数据`是否小于`后边的数据         |
| <=     | 用来判断前边的数据`是否小于或者等于`后边的数据 |
| ==     | 用来判断两个数据`是否相等`                     |
| !=     | 用来判断两个数据`是否不等`                     |

> 注意:
>
> 1. 关系表达式不管简单还是复杂, 最终结果一定是Boolean类型的值, 要么是true, 要么是false.
> 2. 千万不要把==写成=, 否则结果可能不是你想要的.

#### 3.3 代码演示

```scala
//定义两个Int类型的变量a, b, 分别赋值为3, 5
var a:Int = 3
var b:Int = 5
//判断a是否大于b, 并打印结果	
println(a > b)					//false
//判断a是否大于等于b, 并打印结果
println(a >= 3)					//true
//判断a是否小于b, 并打印结果
println(a < b)					//true
//判断a是否小于等于b, 并打印结果
println(a <= 3)					//true
//判断a和b是否不等, 并打印结果
println(a != b)					//true
//判断a和b是否相等, 并打印结果
println(a == b)					//false
//如果把==写成了=, 其实是把变量b的值赋值给变量a
println(a = b)					//输出结果是一对小括号"()", 即: 没有打印值.
println(a)						//再次打印变量a, 打印结果是:5
```

#### 3.4 关系运算符延伸

学过Java的同学会发现, 上述的Scala中的关系运算符用法和Java中是一样的,  那有和Java不一样的地方吗?

答案是: 有. 

| 需求描述           | Scala代码  | Java代码     |
| ------------------ | ---------- | ------------ |
| 比较数据值         | == 或者 != | equals()方法 |
| 比较引用值(地址值) | eq方法     | == 或者 !=   |

**示例**

有一个字符串"abc"，再创建第二个字符串，值为：在第一个字符串后拼接一个空字符串。

然后使用比较这两个字符串是否相等、再查看它们的引用值是否相等。

**参考代码**

```scala
val s1 = "abc"
val s2 = s1 + ""
s1 == s2     //结果是: true,  因为比较的是 数据值
s1.eq(s2)	 //结果是: false, 因为比较的是 地址值
```



### 4. 逻辑运算符

#### 4.1 概述

逻辑运算符指的就是`用来进行逻辑操作的符号`.  可以简单理解为它是: 组合判断. 例如: 判断多个条件是否都满足, 或者满足其中的某一个, 甚至还可以对某个判断结果进行取反操作.

#### 4.2 分类

| 运算符 | 功能解释                                                     |
| ------ | ------------------------------------------------------------ |
| &&     | 逻辑与,  要求所有条件都满足(即: 结果为true),  简单记忆: 有false则整体为false. |
| \|\|   | 逻辑或,  要求只要满足任意一个条件即可,  简单记忆: 有true则整体为true. |
| !      | 逻辑非, 用来进行取反操作的. 即: 以前为true, 取反后为false, 以前为false, 取反后为true. |

> 注意:
>
> 1. 逻辑表达式不管简单还是复杂, 最终结果一定是Boolean类型的值, 要么是true, 要么是false.
> 2. 在Scala代码中, 不能对一个Boolean类型的数据进行**连续取反**操作,  但是在Java中是可以的. 
>    * 即:   !!false,  这样写会报错, 不支持这种写法.

#### 4.3 代码演示

```scala
//相当于: false && true
println(3 > 5 && 2 < 3)		//结果为: false
//我们可以简写代码为:
//逻辑与: 有false则整体为false.
println(false && true)		//结果为: false
println(true && false)		//结果为: false
println(false && false)		//结果为: false
println(true && true)		//结果为: true

println(false || true)		//结果为: true
println(true || false)		//结果为: true
println(false || false)		//结果为: false
println(true || true)		//结果为: true

println(!false)				//结果为: true
println(!true)				//结果为: false
println(!!true)				//这样写会报错, Scala不支持这种写法, 但是Java代码支持这种写法.
```



### 5. 位运算符

#### 5.1 铺垫知识

要想学好`位运算符`, 你必须得知道三个知识点: 

1. 什么是进制
2. 什么是8421码
3. 整数的原码, 反码, 补码计算规则

##### 5.1.1 关于进制

通俗的讲, 逢几进一就是几进制, 例如: 逢二进一就是二进制, 逢十进一就是十进制, 常用的进制有以下几种:

| 进制名称 | 数据组成规则                                                 | 示例                   |
| -------- | ------------------------------------------------------------ | ---------------------- |
| 二进制   | 数据以0b(大小写均可)开头, 由数字0和1组成                     | 0b10001001, 0b00101010 |
| 八进制   | 数据以0开头, 由数字0~7组成                                   | 064,  011              |
| 十进制   | 数据直接写即可,  无特殊开头, 由数字0~9组成                   | 10, 20, 333            |
| 十六进制 | 数据以0x(大小写均可)开头,  由数字0~9, 字母A-F组成(大小写均可) | 0x123F, 0x66ABC        |

> 注意:
>
> ​	关于二进制的数据,  最前边的那一位叫: 符号位, 0表示正数, 1表示负数.  其他位叫: 数值位.
>
> ​	例如: 0b10001001 结果就是一个: 负数,   0b00101010 结果就是一个:  正数.

##### 5.1.2 关于8421码

8421码就是用来描述`二进制位和十进制数据之间的关系的`, 它可以帮助我们快速的计算数据的二进制或十进制形式.

8421码对应关系如下:

​	**二进制位**				0	0	0	0	0	0	0	0		

​	**对应的十进制数据**		128	64	32	16	8	4	2	1

> 注意:
>
>  	1. 计算规则:  二进制位从右往左数, 每多一位, 对应的十进制数据 乘以2.
>  	2. 二进制和十进制相互转换的小技巧: 
>
>      *  二进制转十进制:  获取该二进制位对应的十进制数据, 然后累加即可. 
>        * 例如: 0b101对应的十进制数据计算步骤:  4 + 0 + 1 = 5
>      * 十进制转二进制:  对十进制数据进行拆解, 看哪些数字相加等于它, 然后标记成二进制即可.
>        * 例如: 10 对应的二进制数据计算步骤: 10 = 8 + 2  =   0b1010

##### 5.1.3 关于整数的原反补码计算规则

所谓的原反补码, 其实指的都是二进制数据, 把十进制的数据转成其对应的二进制数据, 该二进制数据即为: 原码.

> 注意: 计算机底层存储, 操作和运算数据, 都是采用`数据的二进制补码形式`来实现的. 

* 正数
  * 正数的原码, 反码, 补码都一样, 不需要特殊计算.
* 负数
  * 负数的反码计算规则:  原码的符号位不变, 数值位按位取反(以前为0现在为1, 以前为1现在为0)
  * 负数的补码计算规则:  反码 + 1

#### 5.2 概述

位运算符指的就是`按照位(Bit)来快速操作数据值`, 它只针对于整型数据.  因为计算机底层存储, 操作, 运算采用的都是数据的二进制补码形式, 且以后我们要经常和海量的数据打交道, 为了提高计算效率, 我们就可以使用位运算符来实现快速修改数据值的操作.

#### 5.3 分类

| 运算符 | 功能解释                                                     |
| ------ | ------------------------------------------------------------ |
| &      | 按位与,  规则: 有0则0,  都为1则为1.                          |
| \|     | 按位或,  规则: 有1则1,  都为0则为0.                          |
| ^      | 按位异或, 规则: 相同为0, 不同为1.                            |
| ~      | 按位取反, 规则: 0变1, 1变0.                                  |
| <<     | 按位左移, 规则: 每左移一位, 相当于该数据乘2, 例如:  2 << 1, 结果为4 |
| \>>    | 按位右移, 规则: 每右移一位, 相当于该数据除2, 例如:  6 >> 1, 结果为3 |

> 注意:
>
> 1. 位运算符只针对于整型数据.
> 2. 运算符操作的是数据的二进制补码形式.
> 3. 小技巧: 一个数字被同一个数字位异或两次, 该数字值不变. 即: 10 ^ 20 ^ 20, 结果还是10

#### 5.4 代码演示

```scala
//定义两个变量a和b, 初始化值分别为: 3, 5
val a = 3			//二进制数据: 0000 0011
val b = 5			//二进制数据: 0000 0101

//结果为: 0000 0001, 转化成十进制, 结果为: 1
println(a & b)		//打印结果为: 1

//结果为: 0000 0111, 转化成十进制, 结果为: 7
println(a | b)		//打印结果为: 7

//结果为: 0000 0110, 转换成十进制, 结果为: 6
println(a ^ b)		//打印结果为: 6

//计算流程: 1111 1100(补码) -> 1111 1011(反码) -> 1000 0100(原码) -> 十进制数据: -4
println(~ a)		//打印结果为: -4

//计算流程: 1000 0011(-3原码) -> 1111 1100(-3反码) -> 1111 1101(-3补码) -> 0000 0010(取反后新补码) -> 十进制数据: 2
println(~ -3)		//打印结果为: 2

//计算流程: 0000 0011(3的补码) -> 0000 1100(新的补码) -> 十进制数据: 12
println(a << 2)		//打印结果为: 12

//计算流程: 0000 0011(3的补码) -> 0000 0001(新的补码) -> 十进制数据: 1
println(a >> 1)		//打印结果为: 1

println(a ^ b ^ b)	//打印结果为: 3
```



### 6. 案例: 交换两个变量的值

#### 6.1 需求

已知有两个Int类型的变量a和b, 初始化值分别为10和20, 请写代码实现变量a和变量b的值的交换.

即最终结果为: a=20, b=10.  

> 注意: 不允许直接写`a=20, b=10`这种代码.

#### 6.2 参考代码

* **方式一:  通过算术运算符实现.**

  ```Scala
  //定义两个Int类型的变量a和b, 初始化值分别为10和20
  var a = 10
  var b = 20
  //将变量a和b的计算结果赋值给变量a
  a = a + b	//a = 30, b = 20
  //计算并赋值
  b = a - b	//a = 30, b = 10
  a = a - b	//a = 20, b = 10
  //打印结果
  println("a: " + a)		//a: 20
  println("b: " + b)		//b: 10
  ```

* **方式二: 通过定义临时变量实现**

  ```scala
  //定义两个Int类型的变量a和b, 初始化值分别为10和20
  var a = 10
  var b = 20
  //定义临时变量temp, 记录变量a的值
  var temp = a			//a = 10, b = 20, temp = 10
  //把变量b的值赋值给a
  a = b					//a = 20, b = 20, temp = 10
  //把临时变量temp的值赋值给b
  b = temp				//a = 20, b = 10, temp = 10
  //打印结果
  println("a: " + a)		//a: 20
  println("b: " + b)		//b: 10
  ```

* **方式三: 通过位运算符实现**

  ```Scala
  //定义两个Int类型的变量a和b, 初始化值分别为10和20
  var a = 10
  var b = 20
  //定义临时变量temp, 记录变量a和b的位异或值(这个值不需要我们计算)
  var temp = a ^ b	//即: temp = 10 ^ 20
  //通过位异或进行交换变量值	
  a = a ^ temp		//运算流程: a = a ^ temp = a ^ a ^ b = 10 ^ 10 ^ 20 = 20
  b = b ^ temp		//运算流程: b = b ^ temp = b ^ a ^ b = 20 ^ 10 ^ 20 = 10
  //打印结果
  println("a: " + a)	//a: 20
  println("b: " + b)	//b: 10
  ```