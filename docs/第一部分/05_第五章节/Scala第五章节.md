

# Scala第五章节

### 章节目标

1. 掌握方法的格式和用法
2. 掌握函数的格式和用法
3. 掌握九九乘法表案例

------

### 1. 方法

#### 1.1 概述

实际开发中, 我们需要编写大量的逻辑代码, 这就势必会涉及到重复的需求. 例如: 求10和20的最大值, 求11和22的最大值, 像这样的需求, `用来进行比较的逻辑代码需要编写两次`, 而如果把比较的逻辑代码放到方法中, 只需要编写一次就可以了, 这就是方法.  scala中的方法和Java方法类似, 但scala与Java定义方法的语法是不一样的。

#### 1.2 语法格式

```scala
def 方法名(参数名:参数类型, 参数名:参数类型) : [return type] = {
    //方法体
}
```

> 注意:
>
> - 参数列表的参数类型不能省略
> - 返回值类型可以省略，由scala编译器自动推断
> - 返回值可以不写return，默认就是{}块表达式的值

#### 1.3 示例

**需求: **

1. 定义一个方法getMax，用来获取两个整型数字的最大值, 并返回结果(最大值).
2. 调用该方法获取最大值, 并将结果打印到控制台上.

**参考代码**

* 方式一: 标准写法

```scala
//1. 定义方法, 用来获取两个整数的最大值.
def getMax(a:Int, b:Int): Int = {
    return if(a > b) a else b
}
//2. 调用方法, 获取最大值.
val max = getMax(10, 20)
//3. 打印结果.
println("max: " + max)
```

* 方式二: 优化版

```scala
//1. 定义方法, 用来获取两个整数的最大值.
def getMax(a:Int, b:Int) = if(a > b) a else b
//2. 调用方法, 获取最大值.
val max = getMax(22, 11)
//3. 打印结果.
println("max: " + max)
```

#### 1.4 返回值类型推断

scala定义方法可以省略返回值的数据类型，由scala自动推断返回值类型。这样方法定义后更加简洁。

> 注意:  定义递归方法，不能省略返回值类型

**示例**

定义递归方法, 求5的阶乘.

**步骤**

1. 定义方法factorial, 用来计算某个数字的阶乘

   > 规律: 1的阶乘等于1, 其他数字的阶乘为: n! = n * (n - 1)!

2. 调用方法, 获取5的阶乘, 并将结果打印到控制台上.

**参考代码**

```scala
//1. 定义方法factorial, 用来计算某个数字的阶乘
def factorial(n:Int):Int = if(n == 1) 1 else n * factorial(n - 1)
//2. 调用方法, 获取5的阶乘.
val result = factorial(5)
//3. 将结果打印到控制台上.
println("result: " + result)
```

#### 1.5 惰性方法

当记录方法返回值的变量被声明为lazy时, 方法的执行将被推迟, 直到我们首次使用该值时, 方法才会执行,  像这样的方法, 就叫: 惰性方法.

> 注意: 
>
>  	1. Java中并没有提供原生态的"惰性"技术, 但是可以通过特定的代码结构实现, 这种结构被称之为: 懒加载(也叫延迟加载)
>  	2. lazy不能修饰var类型的变量. 

**使用场景:**

1. 打开数据库连接

   > `由于表达式执行代价昂贵, 因此我们希望能推迟该操作, 直到我们确实需要表达式结果值时才执行它`

2. 提升某些特定模块的启动时间.

   > `为了缩短模块的启动时间, 可以将当前不需要的某些工作推迟执行`

3. 确保对象中的某些字段能优先初始化

   > `为了确保对象中的某些字段能优先初始化, 我们需要对其他字段进行惰性化处理`

**需求**

定义一个方法用来获取两个整数和, 通过"惰性"技术调用该方法, 然后打印结果.

**参考代码**

```scala
//1. 定义方法, 用来获取两个整数和
def getSum(a:Int, b:Int) = {
    println("getSum方法被执行了...")
    a + b
}
//2. 通过"惰性"方式调用该方法.
lazy val sum = getSum(1, 2)		//此时我们发现getSum方法并没有执行, 说明它的执行被推迟了.

//3. 打印结果, 并观察
println("sum: " + sum) 			//打印结果为sum: 3, 说明首次使用方法返回值时, 方法才会加载执行.
```



#### 1.6 方法参数

scala中的方法参数，使用比较灵活。它支持以下几种类型的参数：

- 默认参数
- 带名参数
- 变长参数

##### 1.6.1 默认参数

在定义方法时可以给参数定义一个默认值。

**示例**

1. 定义一个计算两个整数和的方法，这两个值分别默认为10和20
2. 调用该方法，不传任何参数

**参考代码**

```scala
//1. 定义一个方法, 用来获取两个整数的和
// x，y的默认值分别为10和20
def getSum(x:Int = 10, y:Int = 20) = x + y
//2. 通过默认参数的形式, 调用方法
val sum = getSum()
//3. 打印结果
println("sum: " + sum)
```

##### 1.6.2 带名参数

在调用方法时，可以指定参数的名称来进行调用。

**示例**

1. 定义一个计算两个整数和的方法，这两个值分别默认为10和20
2. 调用该方法，只设置第一个参数的值

**参考代码**

```scala
//1. 定义一个方法, 用来获取两个整数的和
def getSum(x:Int = 10, y:Int = 20) = x + y
//2. 通过默认参数的形式, 调用方法
val sum = getSum(x=1)
//3. 打印结果
println("sum: " + sum)
```

##### 1.6.3 变长参数

如果方法的参数是不固定的，可以将该方法的参数定义成变长参数。

**语法格式：**

```scala
def 方法名(参数名:参数类型*):返回值类型 = {
    //方法体
}
```

> 注意:  
>
>  	1. 在参数类型后面加一个`*`号，表示参数可以是0个或者多个
>  	2. 一个方法有且只能有一个变长参数, 并且变长参数要放到参数列表的最后边.

**示例一: **

1. 定义一个计算若干个值相加的方法
2. 调用方法，传入以下数据：1,2,3,4,5

**参考代码**

```scala
//1. 定义一个计算若干个值相加的方法
def getSum(a:Int*) = a.sum
//2. 调用方法，传入一些整数, 并获取它们的和
val sum = getSum(1,2,3,4,5)
//3. 打印结果
println("sum: " + sum)
```

#### 1.7 方法调用方式

在scala中，有以下几种方法调用方式: 

- 后缀调用法
- 中缀调用法
- 花括号调用法
- 无括号调用法

> 注意: 在编写spark、flink程序时，会经常使用到这些方法调用方式。

##### 1.7.1 后缀调用法

这种方法与Java没有区别, 非常简单.

**语法**

```scala
对象名.方法名(参数)
```

**示例**

使用后缀法调用`Math.abs`, 用来求绝对值

**参考代码**

```scala
//后缀调用法
Math.abs(-1)	//结果为1
```



##### 1.7.2 中缀调用法

**语法**

```scala
对象名 方法名 参数
```

例如：`1 to 10`

> 注意: 如果有多个参数，使用括号括起来
>

**示例**

使用中缀法调用`Math.abs`, 用来求绝对值

```scala
//中缀调用法
Math abs -1		//结果为1
```

**扩展: 操作符即方法**

来看一个表达式, 大家觉得这个表达式像不像方法调用？

```scala
1 + 1
```

在scala中，+ - * / %等这些操作符和Java一样，但在scala中，

- 所有的操作符都是方法
- 操作符是一个方法名字是符号的方法



##### 1.7.3 花括号调用法

语法

```scala
Math.abs{ 
    // 表达式1
    // 表达式2
}
```

> 注意: 方法只有一个参数，才能使用花括号调用法

**示例**

使用花括号调用法`Math.abs`求绝对值

**参考代码**

```scala
//花括号调用法
Math.abs{-10}	//结果为: 10
```



##### 1.7.4 无括号调用法

如果方法没有参数，可以省略方法名后面的括号

**示例**

- 定义一个无参数的方法，打印"Hello, Scala!"
- 使用无括号调用法调用该方法

**参考代码**

```scala
//1. 定义一个无参数的方法，打印"Hello, Scala!"
def sayHello() = println("Hello, Scala!")
//2. 调用方法
sayHello
```

> 注意:  
>
> 1. 在Scala中, 如果方法的返回值类型是Unit类型, 这样的方法称之为**过程(procedure)**
> 2. **过程**的等号(=)可以省略不写. 例如:  
>
> ```scala
> def sayHello() = println("Hello, Scala!")   
> //可以改写为
> def sayHello() { println("Hello, Scala!") }	 //注意: 这个花括号{}不能省略
> ```



### 2. 函数

scala支持函数式编程，将来编写Spark/Flink程序会大量使用到函数, 目前, 我们先对函数做一个简单入门, 在后续的学习过程中, 我们会逐步重点讲解函数的用法.

#### 2.1 定义函数

**语法**

```scala
val 函数变量名 = (参数名:参数类型, 参数名:参数类型....) => 函数体
```

> 注意: 
>
> - 在Scala中, 函数是一个**对象**（变量）
> - 类似于方法，函数也有参数列表和返回值
> - 函数定义不需要使用`def`定义
> - 无需指定返回值类型

#### 2.2 示例

**需求: ** 

1. 定义一个计算两个整数和的函数
2. 调用该函数

**参考代码**

```scala
//1. 定义一个用来计算两个整数和的函数, 并将其赋值给变量sum
val getSum = (x:Int, y:Int) => x + y
//2. 调用函数.
val result = getSum(1,2)
//3. 打印结果
println("result: " + result)
```

#### 2.3 方法和函数的区别

在Java中,  方法和函数之间没有任何区别, 只是叫法不同.  但是在Scala中, 函数和方法就有区别了,  具体如下: 

- 方法是隶属于类或者对象的，在运行时，它是加载到JVM的方法区中
- 可以将函数对象赋值给一个变量，在运行时，它是加载到JVM的堆内存中
- 函数是一个对象，继承自FunctionN，函数对象有apply，curried，toString，tupled这些方法。方法则没有

> 结论: 在Scala中, 函数是对象, 而方法是属于对象的, 所以可以理解为:  **方法归属于函数.**

**示例**

演示方法无法赋值给变量

```scala
//1. 定义方法
def add(x:Int,y:Int)= x + y

//2. 尝试将方法赋值给变量.
//val a = add(1, 2)		//不要这样写, 这样写是在"调用方法", 而不是把方法赋值给变量
val a = add

//3. 上述代码会报错
<console>:12: error: missing argument list for method add
Unapplied methods are only converted to functions when a function type is expected.
You can make this conversion explicit by writing `add _` or `add(_,_)` instead of `add`.
       val a = add

```

#### 2.4 方法转换为函数

有时候需要将方法转换为函数. 例如: 作为变量传递，就需要将方法转换为函数

**格式**

```scala
val 变量名 = 方法名 _		//格式为: 方法名 + 空格 + 下划线
```

> 注意: 使用` _`即可将方法转换为函数

**示例**

1. 定义一个方法用来计算两个整数和
2. 将该方法转换为一个函数，并赋值给变量

**参考代码**

```scala
//1. 定义一个方法用来计算两个整数和
def add(x:Int, y:Int)= x + y
//2. 将该方法转换为一个函数，并赋值给变量
val a = add _
//3. 调用函数, 用来获取两个整数的和.
val result = a(1, 2)
//4. 打印结果
println("result: " + result)
```



### 3. 案例： 打印nn乘法表

#### 3.1 需求

定义方法实现， 根据用户录入的整数， 打印对应的乘法表。

例如： 用户录入5，则打印55乘法表，用户录入9，则打印99乘法表。

#### 3.2 目的

1. 考察`键盘录入和方法, 函数`的综合运用.
2. 体会方法和函数的不同.

#### 3.3 步骤

1. 定义方法(或者函数), 接收一个整型参数.
2. 通过for循环嵌套实现, 根据传入的整数, 打印对应的乘法表.
3. 调用方法(函数), 输出结果.

#### 3.4 参考代码

* 方式一: 通过方法实现

```scala
//1. 定义一个方法, 接收一个整型参数.
def printMT(n:Int) = {   //Multiplication Table(乘法表)
    //2. 通过for循环嵌套实现, 根据传入的整数, 打印对应的乘法表.
    for(i <- 1 to n; j <- 1 to i) {
    	print(s"${j} * ${i} = ${j * i}\t"); 
        if(j==i) println()
    }
}
//3. 调用方法
printMT(5)

//优化版: 上述定义方法的代码可以合并为一行(目前只要能看懂即可)
/*def printMT(n:Int) = for(i <- 1 to n; j <- 1 to i) print(s"${j} * ${i} = ${j * i}" + (if(j==i) "\r\n" else "\t"))*/
```

* 方式二: 通过函数实现

```scala
//1. 定义一个函数, 接收一个整型参数.
val printMT = (n:Int) => {
    //2. 通过for循环嵌套实现, 根据传入的整数, 打印对应的乘法表.
    for(i <- 1 to n; j <- 1 to i) {
    	print(s"${j} * ${i} = ${j * i}\t"); 
        if(j==i) println()
    }
}
//3. 调用函数
printMT(9)

//优化版: 上述定义函数的代码可以合并为一行(目前只要能看懂即可)
/*val printMT = (n:Int) => for(i <- 1 to n; j <- 1 to i) print(s"${j} * ${i} = ${j * i}" + (if(j==i) "\r\n" else "\t"))*/
```

